#Requires -Version 5.1

<#
.SYNOPSIS
Microsoft 365管理ツール - セキュリティ脆弱性テスト

.DESCRIPTION
コードベース内のセキュリティ脆弱性、設定ミス、機密情報漏洩を検査します。
ITSM準拠のセキュリティ要件に基づく包括的なセキュリティ監査を実行します。

.NOTES
Version: 2025.7.17.1
Author: Test/QA Developer
Requires: PowerShell 5.1+
Security: 防御的セキュリティツール（分析専用）

.EXAMPLE
.\security-vulnerability-test.ps1
基本セキュリティ脆弱性スキャンを実行

.EXAMPLE
.\security-vulnerability-test.ps1 -Detailed -GenerateReport
詳細スキャンとレポート生成を実行

.EXAMPLE
.\security-vulnerability-test.ps1 -ScanType "ConfigSecurity"
設定ファイルのセキュリティのみをスキャン
#>

[CmdletBinding()]
param(
    [ValidateSet("All", "CodeSecurity", "ConfigSecurity", "CredentialScan", "PermissionCheck", "CertificateValidation")]
    [string]$ScanType = "All",
    
    [switch]$Detailed,
    [switch]$GenerateReport = $true,
    [string]$OutputPath = "TestReports"
)

# セキュリティスキャン設定
$script:SecurityFindings = @()
$script:CriticalFindings = 0
$script:HighFindings = 0
$script:MediumFindings = 0
$script:LowFindings = 0
$script:ScanStartTime = Get-Date

# 1. 認証情報の露出チェック
Write-Host "1. 認証情報の露出チェック" -ForegroundColor Yellow
Write-Host "   - ハードコードされた認証情報を検索中..." -ForegroundColor Gray

try {
    # 設定ファイルの認証情報チェック
    $configPath = Join-Path $PSScriptRoot "..\Config\appsettings.json"
    if (Test-Path $configPath) {
        $config = Get-Content $configPath -Raw | ConvertFrom-Json
        
        # 危険な値の検出
        $dangerousValues = @(
            "YOUR-CERTIFICATE-THUMBPRINT-HERE",
            "YOUR-CERTIFICATE-PASSWORD-HERE",
            "YOUR-USERNAME-HERE",
            "YOUR-PASSWORD-HERE",
            "YOUR-CLIENT-SECRET-HERE"
        )
        
        $configText = Get-Content $configPath -Raw
        foreach ($dangerousValue in $dangerousValues) {
            if ($configText -like "*$dangerousValue*") {
                $SecurityFindings += [PSCustomObject]@{
                    Category = "認証情報"
                    Severity = "Low"
                    Issue = "プレースホルダー値が残存"
                    File = $configPath
                    Description = "設定ファイルに '$dangerousValue' が残っています"
                    Recommendation = "実際の値に置き換えるか、環境変数を使用してください"
                }
            }
        }
        
        # 環境変数の適切な使用をチェック
        $environmentVariables = @("REACT_APP_MS_TENANT_ID", "REACT_APP_MS_CLIENT_ID", "MS_CLIENT_SECRET", "EXO_CERTIFICATE_PASSWORD")
        $usesEnvironmentVariables = 0
        foreach ($envVar in $environmentVariables) {
            if ($configText -like "*`$`{$envVar`}*") {
                $usesEnvironmentVariables++
            }
        }
        
        if ($usesEnvironmentVariables -gt 0) {
            Write-Host "   ✅ 環境変数の使用を確認 ($usesEnvironmentVariables/$($environmentVariables.Count) 項目)" -ForegroundColor Green
        } else {
            $SecurityFindings += [PSCustomObject]@{
                Category = "認証情報"
                Severity = "High"
                Issue = "環境変数が使用されていない"
                File = $configPath
                Description = "機密情報が平文で保存されている可能性"
                Recommendation = "環境変数を使用して機密情報を設定してください"
            }
        }
    }
} catch {
    $SecurityFindings += [PSCustomObject]@{
        Category = "認証情報"
        Severity = "Medium"
        Issue = "設定ファイルの読み込み失敗"
        File = $configPath
        Description = $_.Exception.Message
        Recommendation = "設定ファイルの存在と権限を確認してください"
    }
}

# 2. PowerShell インジェクション攻撃チェック
Write-Host "2. PowerShell インジェクション攻撃チェック" -ForegroundColor Yellow
Write-Host "   - スクリプトの入力検証を確認中..." -ForegroundColor Gray

$scriptFiles = Get-ChildItem -Path "$PSScriptRoot\.." -Filter "*.ps1" -Recurse
$dangerousPatterns = @(
    "Invoke-Expression",
    "IEX",
    "& \$",
    "cmd /c",
    "powershell.exe",
    "Start-Process.*cmd"
)

foreach ($scriptFile in $scriptFiles) {
    try {
        $content = Get-Content $scriptFile.FullName -Raw
        foreach ($pattern in $dangerousPatterns) {
            if ($content -match $pattern) {
                $SecurityFindings += [PSCustomObject]@{
                    Category = "インジェクション攻撃"
                    Severity = "High"
                    Issue = "危険なコマンド実行パターン"
                    File = $scriptFile.FullName
                    Description = "パターン '$pattern' が検出されました"
                    Recommendation = "入力検証を追加し、安全な実行方法を使用してください"
                }
            }
        }
    } catch {
        # ファイル読み込みエラーは無視
    }
}

# 3. ログファイルの機密情報露出チェック
Write-Host "3. ログファイルの機密情報露出チェック" -ForegroundColor Yellow
Write-Host "   - ログファイルの機密情報を確認中..." -ForegroundColor Gray

$logDirectory = Join-Path $PSScriptRoot "..\Logs"
if (Test-Path $logDirectory) {
    $logFiles = Get-ChildItem -Path $logDirectory -Filter "*.log" -Recurse
    $sensitivePatterns = @(
        "password",
        "secret",
        "token",
        "key",
        "credential",
        "cert.*password"
    )
    
    foreach ($logFile in $logFiles) {
        try {
            $content = Get-Content $logFile.FullName -Raw
            foreach ($pattern in $sensitivePatterns) {
                if ($content -match $pattern) {
                    $SecurityFindings += [PSCustomObject]@{
                        Category = "ログ機密情報"
                        Severity = "Medium"
                        Issue = "ログファイルに機密情報が含まれている可能性"
                        File = $logFile.FullName
                        Description = "パターン '$pattern' が検出されました"
                        Recommendation = "ログ出力時に機密情報をマスクしてください"
                    }
                }
            }
        } catch {
            # ファイル読み込みエラーは無視
        }
    }
}

# 4. ファイル権限チェック
Write-Host "4. ファイル権限チェック" -ForegroundColor Yellow
Write-Host "   - 重要ファイルの権限を確認中..." -ForegroundColor Gray

$criticalFiles = @(
    (Join-Path $PSScriptRoot "..\Config\appsettings.json"),
    (Join-Path $PSScriptRoot "..\Certificates\*.pfx")
)

foreach ($filePath in $criticalFiles) {
    if ($filePath -like "*\*") {
        # ワイルドカードパターンの場合
        $files = Get-ChildItem -Path $filePath -ErrorAction SilentlyContinue
        foreach ($file in $files) {
            try {
                $acl = Get-Acl $file.FullName
                $everyoneAccess = $acl.Access | Where-Object { $_.IdentityReference -eq "Everyone" }
                if ($everyoneAccess) {
                    $SecurityFindings += [PSCustomObject]@{
                        Category = "ファイル権限"
                        Severity = "High"
                        Issue = "重要ファイルに Everyone アクセス権限"
                        File = $file.FullName
                        Description = "誰でもアクセス可能な状態です"
                        Recommendation = "ファイル権限を制限してください"
                    }
                }
            } catch {
                # 権限確認エラーは無視
            }
        }
    } else {
        # 単一ファイルの場合
        if (Test-Path $filePath) {
            try {
                $acl = Get-Acl $filePath
                $everyoneAccess = $acl.Access | Where-Object { $_.IdentityReference -eq "Everyone" }
                if ($everyoneAccess) {
                    $SecurityFindings += [PSCustomObject]@{
                        Category = "ファイル権限"
                        Severity = "High"
                        Issue = "重要ファイルに Everyone アクセス権限"
                        File = $filePath
                        Description = "誰でもアクセス可能な状態です"
                        Recommendation = "ファイル権限を制限してください"
                    }
                }
            } catch {
                # 権限確認エラーは無視
            }
        }
    }
}

# 5. 証明書セキュリティチェック
Write-Host "5. 証明書セキュリティチェック" -ForegroundColor Yellow
Write-Host "   - 証明書の有効性と設定を確認中..." -ForegroundColor Gray

try {
    $certDirectory = Join-Path $PSScriptRoot "..\Certificates"
    if (Test-Path $certDirectory) {
        $certFiles = Get-ChildItem -Path $certDirectory -Filter "*.pfx"
        foreach ($certFile in $certFiles) {
            try {
                # 証明書の有効期限チェック
                $cert = New-Object System.Security.Cryptography.X509Certificates.X509Certificate2
                $cert.Import($certFile.FullName)
                
                $daysToExpiry = ($cert.NotAfter - (Get-Date)).Days
                if ($daysToExpiry -lt 30) {
                    $SecurityFindings += [PSCustomObject]@{
                        Category = "証明書"
                        Severity = "High"
                        Issue = "証明書の有効期限が近い"
                        File = $certFile.FullName
                        Description = "証明書の有効期限まで $daysToExpiry 日です"
                        Recommendation = "証明書を更新してください"
                    }
                }
            } catch {
                # パスワード保護された証明書の場合は期限チェックをスキップ
            }
        }
    }
} catch {
    # 証明書チェックエラーは無視
}

# 6. Microsoft Graph API アクセス権限チェック
Write-Host "6. Microsoft Graph API アクセス権限チェック" -ForegroundColor Yellow
Write-Host "   - APIアクセス権限の妥当性を確認中..." -ForegroundColor Gray

try {
    $configPath = Join-Path $PSScriptRoot "..\Config\appsettings.json"
    if (Test-Path $configPath) {
        $config = Get-Content $configPath -Raw | ConvertFrom-Json
        $scopes = $config.EntraID.Scopes
        
        # 過剰権限のチェック
        $highRiskScopes = @(
            "https://graph.microsoft.com/Directory.ReadWrite.All",
            "https://graph.microsoft.com/User.ReadWrite.All",
            "https://graph.microsoft.com/Group.ReadWrite.All",
            "https://graph.microsoft.com/Files.ReadWrite.All"
        )
        
        foreach ($scope in $scopes) {
            if ($scope -in $highRiskScopes) {
                $SecurityFindings += [PSCustomObject]@{
                    Category = "API権限"
                    Severity = "Medium"
                    Issue = "過剰なAPI権限"
                    File = $configPath
                    Description = "高リスクスコープ: $scope"
                    Recommendation = "必要最小限の権限に制限してください"
                }
            }
        }
    }
} catch {
    # API権限チェックエラーは無視
}

# 7. セキュリティ設定の確認
Write-Host "7. セキュリティ設定の確認" -ForegroundColor Yellow
Write-Host "   - セキュリティ設定を確認中..." -ForegroundColor Gray

try {
    $configPath = Join-Path $PSScriptRoot "..\Config\appsettings.json"
    if (Test-Path $configPath) {
        $config = Get-Content $configPath -Raw | ConvertFrom-Json
        $security = $config.Security
        
        # 重要なセキュリティ設定の確認
        $securityChecks = @(
            @{ Setting = "EncryptSensitiveData"; Expected = $true; Severity = "High" },
            @{ Setting = "RequireMFAForAdmins"; Expected = $true; Severity = "High" },
            @{ Setting = "EnableAuditTrail"; Expected = $true; Severity = "Medium" }
        )
        
        foreach ($check in $securityChecks) {
            if ($security.($check.Setting) -ne $check.Expected) {
                $SecurityFindings += [PSCustomObject]@{
                    Category = "セキュリティ設定"
                    Severity = $check.Severity
                    Issue = "セキュリティ設定が推奨値と異なる"
                    File = $configPath
                    Description = "$($check.Setting) = $($security.($check.Setting)), 推奨値: $($check.Expected)"
                    Recommendation = "セキュリティ設定を推奨値に変更してください"
                }
            }
        }
    }
} catch {
    # セキュリティ設定チェックエラーは無視
}

# 結果の表示
Write-Host ""
Write-Host "=== セキュリティ診断結果 ===" -ForegroundColor Cyan

if ($SecurityFindings.Count -eq 0) {
    Write-Host "✅ 重大な脆弱性は発見されませんでした" -ForegroundColor Green
} else {
    Write-Host "⚠️  $($SecurityFindings.Count) 件の問題が発見されました" -ForegroundColor Yellow
    Write-Host ""
    
    # 深刻度別の集計
    $criticalCount = ($SecurityFindings | Where-Object { $_.Severity -eq "Critical" }).Count
    $highCount = ($SecurityFindings | Where-Object { $_.Severity -eq "High" }).Count
    $mediumCount = ($SecurityFindings | Where-Object { $_.Severity -eq "Medium" }).Count
    $lowCount = ($SecurityFindings | Where-Object { $_.Severity -eq "Low" }).Count
    
    Write-Host "深刻度別集計:" -ForegroundColor White
    if ($criticalCount -gt 0) { Write-Host "  Critical: $criticalCount" -ForegroundColor Red }
    if ($highCount -gt 0) { Write-Host "  High: $highCount" -ForegroundColor Magenta }
    if ($mediumCount -gt 0) { Write-Host "  Medium: $mediumCount" -ForegroundColor Yellow }
    if ($lowCount -gt 0) { Write-Host "  Low: $lowCount" -ForegroundColor Cyan }
    
    Write-Host ""
    Write-Host "詳細:" -ForegroundColor White
    
    foreach ($finding in $SecurityFindings) {
        $color = switch ($finding.Severity) {
            "Critical" { "Red" }
            "High" { "Magenta" }
            "Medium" { "Yellow" }
            "Low" { "Cyan" }
            default { "White" }
        }
        
        Write-Host "[$($finding.Severity)] $($finding.Category): $($finding.Issue)" -ForegroundColor $color
        Write-Host "  ファイル: $($finding.File)" -ForegroundColor Gray
        Write-Host "  詳細: $($finding.Description)" -ForegroundColor Gray
        Write-Host "  推奨対応: $($finding.Recommendation)" -ForegroundColor Gray
        Write-Host ""
    }
}

# CSV形式でレポート出力
try {
    $reportPath = Join-Path $PSScriptRoot "TestReports\security-vulnerability-report_$(Get-Date -Format 'yyyyMMdd_HHmmss').csv"
    
    # TestReportsディレクトリを作成
    $reportDir = Split-Path $reportPath
    if (-not (Test-Path $reportDir)) {
        New-Item -ItemType Directory -Path $reportDir -Force | Out-Null
    }
    
    $SecurityFindings | Export-Csv -Path $reportPath -NoTypeInformation -Encoding UTF8
    Write-Host "📊 セキュリティレポートを出力しました: $reportPath" -ForegroundColor Green
} catch {
    Write-Host "⚠️ レポート出力エラー: $($_.Exception.Message)" -ForegroundColor Yellow
}

Write-Host ""
Write-Host "🔒 セキュリティ脆弱性テスト完了" -ForegroundColor Green